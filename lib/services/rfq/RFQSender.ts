// RFQ Sender - Envía RFQs a proveedores

import { prisma } from '@/lib/prisma'
import { RFQGenerator } from './RFQGenerator'
import { sendEmail } from '@/lib/email'

export class RFQSender {
  /**
   * Envía un RFQ a los proveedores invitados
   */
  static async sendRFQ(rfqId: string) {
    const rfq = await prisma.rFQ.findUnique({
      where: { id: rfqId },
      include: {
        request: {
          include: {
            client: true,
          },
        },
        items: true,
        invitedSuppliers: {
          include: {
            supplier: true,
          },
        },
      },
    })

    if (!rfq) {
      throw new Error('RFQ no encontrado')
    }

    // Generar contenido
    const content = RFQGenerator.generateContent(
      {
        id: rfq.id,
        requestId: rfq.requestId,
        status: rfq.status,
        title: rfq.title,
        description: rfq.description || undefined,
        deadline: rfq.deadline,
        items: rfq.items.map((item) => ({
          id: item.id,
          rfqId: item.rfqId,
          specItemId: item.specItemId || undefined,
          name: item.name,
          description: item.description || undefined,
          category: item.category,
          quantity: item.quantity,
          unit: item.unit,
          specifications: (item.specifications as Record<string, any>) || undefined,
        })),
        invitedSuppliers: [],
        quotes: [],
        autoGenerated: rfq.autoGenerated,
        sentAt: rfq.sentAt || undefined,
        createdAt: rfq.createdAt,
        updatedAt: rfq.updatedAt,
      },
      rfq.request.client.name
    )

    // Enviar a cada proveedor invitado
    const sendResults = await Promise.allSettled(
      rfq.invitedSuppliers.map(async (invitation) => {
        try {
          await sendEmail({
            to: invitation.supplier.email,
            subject: content.subject,
            text: content.body,
            html: content.htmlBody,
          })

          // Actualizar fecha de envío
          await prisma.rFQSupplier.update({
            where: { id: invitation.id },
            data: {
              viewedAt: new Date(),
            },
          })

          return { supplierId: invitation.supplierId, success: true }
        } catch (error) {
          console.error(
            `Error enviando RFQ a proveedor ${invitation.supplierId}:`,
            error
          )
          return { supplierId: invitation.supplierId, success: false, error }
        }
      })
    )

    // Actualizar RFQ como enviado
    await prisma.rFQ.update({
      where: { id: rfqId },
      data: {
        status: 'sent',
        sentAt: new Date(),
      },
    })

    return {
      sent: true,
      totalSuppliers: rfq.invitedSuppliers.length,
      results: sendResults.map((result) =>
        result.status === 'fulfilled' ? result.value : { success: false }
      ),
    }
  }

  /**
   * Envía recordatorio a proveedores que no han respondido
   */
  static async sendReminder(rfqId: string) {
    const rfq = await prisma.rFQ.findUnique({
      where: { id: rfqId },
      include: {
        request: {
          include: {
            client: true,
          },
        },
        items: true,
        invitedSuppliers: {
          include: {
            supplier: true,
          },
          where: {
            respondedAt: null,
          },
        },
      },
    })

    if (!rfq) {
      throw new Error('RFQ no encontrado')
    }

    const content = RFQGenerator.generateContent(
      {
        id: rfq.id,
        requestId: rfq.requestId,
        status: rfq.status,
        title: rfq.title,
        description: rfq.description || undefined,
        deadline: rfq.deadline,
        items: rfq.items.map((item) => ({
          id: item.id,
          rfqId: item.rfqId,
          specItemId: item.specItemId || undefined,
          name: item.name,
          description: item.description || undefined,
          category: item.category,
          quantity: item.quantity,
          unit: item.unit,
          specifications: (item.specifications as Record<string, any>) || undefined,
        })),
        invitedSuppliers: [],
        quotes: [],
        autoGenerated: rfq.autoGenerated,
        sentAt: rfq.sentAt || undefined,
        createdAt: rfq.createdAt,
        updatedAt: rfq.updatedAt,
      },
      rfq.request.client.name
    )

    // Agregar mensaje de recordatorio
    const reminderSubject = `[Recordatorio] ${content.subject}`
    const reminderBody = `Este es un recordatorio sobre la siguiente solicitud de cotización:\n\n${content.body}`

    const sendResults = await Promise.allSettled(
      rfq.invitedSuppliers.map(async (invitation) => {
        try {
          await sendEmail({
            to: invitation.supplier.email,
            subject: reminderSubject,
            text: reminderBody,
            html: content.htmlBody,
          })

          return { supplierId: invitation.supplierId, success: true }
        } catch (error) {
          console.error(
            `Error enviando recordatorio a proveedor ${invitation.supplierId}:`,
            error
          )
          return { supplierId: invitation.supplierId, success: false, error }
        }
      })
    )

    return {
      sent: true,
      totalSuppliers: rfq.invitedSuppliers.length,
      results: sendResults.map((result) =>
        result.status === 'fulfilled' ? result.value : { success: false }
      ),
    }
  }
}

