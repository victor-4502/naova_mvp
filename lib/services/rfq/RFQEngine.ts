// @ts-nocheck
// TODO: Activar cuando el schema POS esté activo

// RFQ Engine - Motor principal de RFQ

import { prisma } from '@/lib/prisma'
import { RFQSender } from './RFQSender'
import { QuoteReceiver } from './QuoteReceiver'
import type { RFQ, RFQItem } from '@/lib/types/rfq'

export interface CreateRFQInput {
  requestId: string
  title: string
  description?: string
  deadline: Date
  supplierIds: string[]
  autoGenerated?: boolean
}

export class RFQEngine {
  /**
   * Crea un RFQ automáticamente desde un request
   */
  static async createRFQFromRequest(
    requestId: string,
    supplierIds: string[]
  ): Promise<RFQ> {
    // Obtener request con specs
    const request = await prisma.request.findUnique({
      where: { id: requestId },
      include: {
        specs: {
          include: {
            items: true,
          },
        },
      },
    })

    if (!request) {
      throw new Error('Request no encontrado')
    }

    if (!request.specs) {
      throw new Error('Request no tiene especificaciones completas')
    }

    // Calcular fecha límite (7 días por defecto)
    const deadline = new Date()
    deadline.setDate(deadline.getDate() + 7)

    // Crear RFQ
    const rfq = await prisma.rFQ.create({
      data: {
        requestId,
        title: request.specs.items.length === 1
          ? request.specs.items[0].name
          : `RFQ - ${request.category || 'Compra'}`,
        description: `RFQ generado automáticamente para el request ${requestId}`,
        deadline,
        status: 'draft',
        autoGenerated: true,
        items: {
          create: request.specs.items.map((item) => ({
            specItemId: item.id,
            name: item.name,
            description: item.description,
            category: item.category,
            subcategory: item.subcategory,
            quantity: item.quantity,
            unit: item.unit,
            specifications: item.specifications,
          })),
        },
        invitedSuppliers: {
          create: supplierIds.map((supplierId) => ({
            supplierId,
          })),
        },
      },
      include: {
        items: true,
        invitedSuppliers: {
          include: {
            supplier: true,
          },
        },
      },
    })

    // Actualizar estado del request
    await prisma.request.update({
      where: { id: requestId },
      data: {
        status: 'rfq_sent',
        pipelineStage: 'quotes_in_progress',
      },
    })

    return this.mapRFQ(rfq)
  }

  /**
   * Crea un RFQ manualmente
   */
  static async createRFQ(input: CreateRFQInput): Promise<RFQ> {
    // Verificar que el request existe
    const request = await prisma.request.findUnique({
      where: { id: input.requestId },
      include: {
        specs: {
          include: {
            items: true,
          },
        },
      },
    })

    if (!request) {
      throw new Error('Request no encontrado')
    }

    // Crear RFQ
    const rfq = await prisma.rFQ.create({
      data: {
        requestId: input.requestId,
        title: input.title,
        description: input.description,
        deadline: input.deadline,
        status: 'draft',
        autoGenerated: input.autoGenerated || false,
        items: request.specs
          ? {
              create: request.specs.items.map((item) => ({
                specItemId: item.id,
                name: item.name,
                description: item.description,
                category: item.category,
                subcategory: item.subcategory,
                quantity: item.quantity,
                unit: item.unit,
                specifications: item.specifications,
              })),
            }
          : undefined,
        invitedSuppliers: {
          create: input.supplierIds.map((supplierId) => ({
            supplierId,
          })),
        },
      },
      include: {
        items: true,
        invitedSuppliers: {
          include: {
            supplier: true,
          },
        },
      },
    })

    return this.mapRFQ(rfq)
  }

  /**
   * Envía un RFQ a los proveedores
   */
  static async sendRFQ(rfqId: string) {
    return RFQSender.sendRFQ(rfqId)
  }

  /**
   * Recibe una cotización
   */
  static async receiveQuote(input: QuoteReceiver.QuoteSubmissionInput) {
    return QuoteReceiver.receiveQuote(input)
  }

  /**
   * Obtiene un RFQ por ID
   */
  static async getRFQ(rfqId: string): Promise<RFQ | null> {
    const rfq = await prisma.rFQ.findUnique({
      where: { id: rfqId },
      include: {
        items: true,
        invitedSuppliers: {
          include: {
            supplier: true,
          },
        },
        quotes: {
          include: {
            items: true,
            supplier: true,
          },
        },
      },
    })

    if (!rfq) return null

    return this.mapRFQ(rfq)
  }

  /**
   * Mapea RFQ de Prisma a tipo RFQ
   */
  private static mapRFQ(rfq: any): RFQ {
    return {
      id: rfq.id,
      requestId: rfq.requestId,
      status: rfq.status,
      title: rfq.title,
      description: rfq.description || undefined,
      deadline: rfq.deadline,
      items: rfq.items.map((item: any) => ({
        id: item.id,
        rfqId: item.rfqId,
        specItemId: item.specItemId || undefined,
        name: item.name,
        description: item.description || undefined,
        category: item.category,
        quantity: item.quantity,
        unit: item.unit,
        specifications: (item.specifications as Record<string, any>) || undefined,
      })),
      invitedSuppliers: rfq.invitedSuppliers.map((inv: any) => ({
        id: inv.id,
        rfqId: inv.rfqId,
        supplierId: inv.supplierId,
        invitedAt: inv.invitedAt,
        viewedAt: inv.viewedAt || undefined,
        respondedAt: inv.respondedAt || undefined,
      })),
      quotes: rfq.quotes?.map((quote: any) => ({
        id: quote.id,
        rfqId: quote.rfqId,
        supplierId: quote.supplierId,
        status: quote.status as any,
        subtotal: quote.subtotal,
        taxes: quote.taxes,
        shipping: quote.shipping,
        total: quote.total,
        validUntil: quote.validUntil,
        deliveryDays: quote.deliveryDays,
        paymentTerms: quote.paymentTerms || undefined,
        warranty: quote.warranty || undefined,
        availability: quote.availability || undefined,
        items: quote.items.map((item: any) => ({
          id: item.id,
          quoteId: item.quoteId,
          rfqItemId: item.rfqItemId || undefined,
          specItemId: item.specItemId || undefined,
          name: item.name,
          quantity: item.quantity,
          unit: item.unit,
          unitPrice: item.unitPrice,
          subtotal: item.subtotal,
          brand: item.brand || undefined,
          model: item.model || undefined,
          specifications: (item.specifications as Record<string, any>) || undefined,
        })),
        comparisonScore: quote.comparisonScore || undefined,
        notes: quote.notes || undefined,
        submittedAt: quote.submittedAt,
        updatedAt: quote.updatedAt,
      })) || [],
      autoGenerated: rfq.autoGenerated,
      sentAt: rfq.sentAt || undefined,
      createdAt: rfq.createdAt,
      updatedAt: rfq.updatedAt,
    }
  }
}

